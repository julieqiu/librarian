// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package gcloud

import (
	"fmt"
	"slices"
	"strings"

	"github.com/googleapis/librarian/internal/sidekick/api"
	"github.com/googleapis/librarian/internal/surfer/gcloud/utils"
	"github.com/iancoleman/strcase"
)

// NewCommand constructs a single gcloud command definition from an API method.
// This function assembles all the necessary pieces: help text, arguments,
// request details, and async configuration.
func NewCommand(method *api.Method, overrides *Config, model *api.API, service *api.Service) (*Command, error) {
	// We look up the help text and API definition for this specific method in the
	// `gcloud.yaml` configuration file.
	rule := findHelpTextRule(method, overrides)

	// We initialize the command with some default values.
	cmd := &Command{
		AutoGenerated: true,
	}

	if len(overrides.APIs) > 0 {
		cmd.Hidden = overrides.APIs[0].RootIsHidden
	} else {
		// Default to hidden if no API overrides are provided.
		cmd.Hidden = true
	}

	// If a help text rule was found in the config, we apply it to the command.
	if rule != nil {
		cmd.HelpText = HelpText{
			Brief:       rule.HelpText.Brief,
			Description: rule.HelpText.Description,
			Examples:    strings.Join(rule.HelpText.Examples, "\n\n"),
		}
	}

	// Infer default release track from proto package.
	// TODO(https://github.com/googleapis/librarian/issues/3289): Allow gcloud config to overwrite the track for this command.
	inferredTrack := utils.InferTrackFromPackage(method.Service.Package)
	cmd.ReleaseTracks = []string{strings.ToUpper(inferredTrack)}

	// The core of the command generation happens here: we generate the arguments,
	// request details, and async configuration.
	args, err := newArguments(method, overrides, model, service)
	if err != nil {
		return nil, err
	}
	cmd.Arguments = args
	cmd.Request = newRequest(method, overrides, model)
	if method.OperationInfo != nil {
		cmd.Async = newAsync(method, overrides)
	}

	return cmd, nil
}

// newArguments generates the set of arguments for a command by parsing the
// fields of the method's request message.
func newArguments(method *api.Method, overrides *Config, model *api.API, service *api.Service) (Arguments, error) {
	args := Arguments{}
	if method.InputType == nil {
		return args, nil
	}

	// TODO(https://github.com/googleapis/librarian/issues/3412): Refactor to use a dispatch pattern (IsIgnored, IsResourceArg, IsArg) to handle field processing.
	// We iterate over each field in the method's request message (e.g., `CreateInstanceRequest`).
	for _, field := range method.InputType.Fields {
		// We check if the current field represents the primary resource of the command.
		// For example, in a `CreateInstance` method, this would be the `instance_id` field.
		if utils.IsPrimaryResource(field, method) {
			// If it is the primary resource, we generate a special positional argument for it.
			param := newPrimaryResourceParam(field, method, model, overrides, service)
			args.Params = append(args.Params, param)
			continue
		}

		// For all other fields, we generate a standard flag argument. If the field
		// is a nested message, its fields will be "flattened" into top-level flags.
		// For example, a field `instance.description` becomes the `--description` flag.
		// TODO(https://github.com/googleapis/librarian/issues/3413): Improve error handling strategy (Error vs Skip) and messaging.
		if err := addFlattenedParams(field, field.JSONName, &args, overrides, model, service, method); err != nil {
			return Arguments{}, err
		}
	}
	return args, nil
}

// shouldSkipParam determines if a field should be excluded from the generated command arguments.
func shouldSkipParam(field *api.Field, method *api.Method) bool {
	// The "parent" field is implicit in the command context (usually handled by the primary resource or hierarchy).
	if field.Name == "parent" {
		return true
	}

	// The "name" field is usually the primary resource identifier, handled separately.
	if field.Name == "name" {
		return true
	}

	// The "update_mask" field is handled automatically by the gcloud framework
	// based on the flags provided by the user. It should not be exposed as a flag.
	if field.Name == "update_mask" {
		return true
	}

	// Output-only fields are read-only and should not be settable via CLI flags.
	if slices.Contains(field.Behavior, api.FIELD_BEHAVIOR_OUTPUT_ONLY) {
		return true
	}

	// For Update commands, fields marked as IMMUTABLE cannot be changed and should be hidden.
	if utils.IsUpdate(method) && slices.Contains(field.Behavior, api.FIELD_BEHAVIOR_IMMUTABLE) {
		return true
	}

	return false
}

// addFlattenedParams recursively processes a field and its sub-fields to generate
// a flat list of command-line flags. This is necessary for nested messages in
// the request proto.
func addFlattenedParams(field *api.Field, prefix string, args *Arguments, overrides *Config, model *api.API, service *api.Service, method *api.Method) error {
	if shouldSkipParam(field, method) {
		return nil
	}

	// If the field is a nested message (and not a map, which is handled differently),
	// we need to recurse into its fields. This is the "flattening" process.
	// For example, in the Parallelstore API, the `CreateInstanceRequest` message
	// has a field named `instance` which is of type `Instance`. The `Instance`
	// message itself has fields like `description` and `capacity_gib`.
	// This block will recurse into the `Instance` message's fields.
	if field.MessageType != nil && !field.Map {
		for _, f := range field.MessageType.Fields {
			// The prefix is updated to create a dot-separated path for the `api_field`.
			// Continuing the example: when processing the `capacity_gib` field inside the
			// `Instance` message, the prefix will become "instance.capacityGib". This
			// results in a `--capacity-gib` flag that maps to the correct nested field.
			if err := addFlattenedParams(f, fmt.Sprintf("%s.%s", prefix, f.JSONName), args, overrides, model, service, method); err != nil {
				return err
			}
		}
		return nil
	}

	// If the field is a scalar, map, or enum, we generate a parameter for it.
	param, err := newParam(field, prefix, overrides, model, service, method)
	if err != nil {
		return err
	}
	args.Params = append(args.Params, param)
	return nil
}

// newParam creates a single command-line argument (a `Param` struct) from a proto field.
func newParam(field *api.Field, apiField string, overrides *Config, model *api.API, service *api.Service, method *api.Method) (Param, error) {
	// We initialize the Param with the basic information derived from the field.
	// TODO(https://github.com/googleapis/librarian/issues/3414): Abstract away casing logic in the model.
	param := Param{
		// The command-line flag name is the kebab-case version of the field name.
		// Example: `requestId` -> `request-id`
		ArgName: strcase.ToKebab(field.Name),
		// The `api_field` is the dot-separated path to the field in the request message.
		APIField: apiField,
		// We determine if the field is required based on the `(google.api.field_behavior)` annotation.
		Required: field.DocumentAsRequired(),
		// We check if the field is repeated in the proto.
		Repeated: field.Repeated,
	}

	// Now we handle the different types of fields.
	if field.ResourceReference != nil {
		// If the field is a resource reference (e.g., a field for a network), we
		// generate a `ResourceSpec` for it. This tells gcloud how to parse the
		// resource name provided by the user.
		spec, err := newResourceReferenceSpec(field, model, overrides, service)
		if err != nil {
			return Param{}, err
		}
		param.ResourceSpec = spec
		param.ResourceMethodParams = map[string]string{
			apiField: "{__relative_name__}",
		}
	} else if field.Map {
		// If the field is a map, we generate a spec for its key-value pairs.
		param.Repeated = true
		param.Spec = []ArgSpec{
			{APIField: "key"},
			{APIField: "value"},
		}
	} else if field.EnumType != nil {
		// If the field is an enum, we generate a list of choices for the flag.
		for _, v := range field.EnumType.Values {
			// We skip the default "UNSPECIFIED" value, as it's not a valid choice for the user.
			if strings.HasSuffix(v.Name, "_UNSPECIFIED") {
				continue
			}
			param.Choices = append(param.Choices, Choice{
				ArgValue:  strcase.ToKebab(v.Name),
				EnumValue: v.Name,
			})
		}
	} else {
		// If it's a scalar type (string, int, bool, etc.), we map its proto type
		// to the corresponding gcloud type.
		param.Type = utils.GetGcloudType(field.Typez)
	}

	// For Update commands, maps and repeated fields are often clearable.
	if utils.IsUpdate(method) && param.Repeated {
		param.Clearable = true
	}

	// We try to find help text for this field in the `gcloud.yaml` config.
	// If none is found, we generate a default help text.
	if rule := findFieldHelpTextRule(field, overrides); rule != nil {
		param.HelpText = rule.HelpText.Brief
	} else {
		// TODO(https://github.com/googleapis/librarian/issues/3033): improve default help text inference
		param.HelpText = fmt.Sprintf("Value for the `%s` field.", strcase.ToKebab(field.Name))
	}
	return param, nil
}

// newPrimaryResourceParam creates the main positional resource argument for a command.
// This is the argument that represents the resource being acted upon (e.g., the instance name).
func newPrimaryResourceParam(field *api.Field, method *api.Method, model *api.API, _ *Config, service *api.Service) Param {
	// We first need to get the full resource definition for the method.
	resource := utils.GetResourceForMethod(method, model)
	var segments []api.PathSegment
	// TODO(https://github.com/googleapis/librarian/issues/3415): Support multiple resource patterns and multitype resources.
	if resource != nil && len(resource.Patterns) > 0 {
		segments = resource.Patterns[0]
	}

	// We construct the gcloud collection path from the resource's pattern string.
	// Example: `projects/{project}/locations/{location}/instances/{instance}` -> `projects.locations.instances`
	collectionPath := utils.GetCollectionPathFromSegments(segments)
	hostParts := strings.Split(service.DefaultHost, ".")
	shortServiceName := hostParts[0]

	// We determine the singular name of the resource.
	// For `Create` methods, this comes from the `_id` field. For others, it's the `name` field.
	resourceName := strcase.ToSnake(strings.TrimSuffix(field.Name, "_id"))
	if field.Name == "name" {
		resourceName = utils.GetSingularFromSegments(segments)
	}

	// We generate a helpful help text based on whether the command is a `Create` command or not.
	helpText := fmt.Sprintf("The %s to create.", resourceName)
	if !utils.IsCreate(method) {
		helpText = fmt.Sprintf("The %s to operate on.", resourceName)
	}

	// We assemble the final `Param` struct with all the necessary information for a primary resource.
	param := Param{
		HelpText:          helpText,
		IsPositional:      true,
		IsPrimaryResource: true,
		Required:          true,
		ResourceSpec: &ResourceSpec{
			Name:                  resourceName,
			PluralName:            utils.GetPluralResourceNameForMethod(method, model),
			Collection:            fmt.Sprintf("%s.%s", shortServiceName, collectionPath),
			DisableAutoCompleters: false,
			Attributes:            newAttributesFromSegments(segments),
		},
	}

	if utils.IsCreate(method) {
		param.RequestIDField = strcase.ToLowerCamel(field.Name)
	}

	return param
}

// newResourceReferenceSpec creates a ResourceSpec for a field that references
// another resource type (e.g., a `--network` flag).
func newResourceReferenceSpec(field *api.Field, model *api.API, _ *Config, service *api.Service) (*ResourceSpec, error) {
	// We iterate through all the resource definitions in the API model to find the
	// one that matches the type of our resource reference.
	for _, def := range model.ResourceDefinitions {
		if def.Type == field.ResourceReference.Type {
			if len(def.Patterns) == 0 {
				return nil, fmt.Errorf("resource definition for %q has no patterns", def.Type)
			}
			// TODO(https://github.com/googleapis/librarian/issues/3415): Support multiple resource patterns and multitype resources.
			segments := def.Patterns[0]

			// We determine the plural name, using the explicit `plural` field if available,
			// and falling back to parsing the pattern otherwise.
			pluralName := def.Plural
			if pluralName == "" {
				pluralName = utils.GetPluralFromSegments(segments)
			}

			// We determine the singular name from the pattern.
			name := utils.GetSingularFromSegments(segments)

			// We construct the full gcloud collection path for the referenced resource
			//assuming the current service is the current command.
			hostParts := strings.Split(service.DefaultHost, ".")
			shortServiceName := hostParts[0]
			baseCollectionPath := utils.GetCollectionPathFromSegments(segments)
			fullCollectionPath := fmt.Sprintf("%s.%s", shortServiceName, baseCollectionPath)

			// We assemble and return the `ResourceSpec`.
			return &ResourceSpec{
				Name:       name,
				PluralName: pluralName,
				Collection: fullCollectionPath,
				// TODO(https://github.com/googleapis/librarian/issues/3416): Investigate and enable auto-completers for referenced resources.
				DisableAutoCompleters: true,
				Attributes:            newAttributesFromSegments(segments),
			}, nil
		}
	}
	return nil, fmt.Errorf("resource definition not found for type %q", field.ResourceReference.Type)
}

// newAttributesFromSegments parses a structured resource pattern and extracts the attributes
// that make up the resource's name.
func newAttributesFromSegments(segments []api.PathSegment) []Attribute {
	var attributes []Attribute

	// We iterate over the segments of the pattern.
	for i, part := range segments {
		// A variable segment is enclosed in curly braces.
		if part.Variable == nil {
			continue
		}

		// The `attribute_name` is the name of the variable (e.g., "project").
		if len(part.Variable.FieldPath) == 0 {
			continue
		}
		name := part.Variable.FieldPath[len(part.Variable.FieldPath)-1]
		var parameterName string

		// The `parameter_name` is derived from the preceding literal segment
		// (e.g., "projects" -> "projectsId"). This is a gcloud convention.
		if i > 0 && segments[i-1].Literal != nil {
			parameterName = *segments[i-1].Literal + "Id"
		} else {
			// This is a fallback for the unlikely case that a pattern starts with a variable.
			parameterName = name + "sId"
		}

		attr := Attribute{
			AttributeName: name,
			ParameterName: parameterName,
			Help:          fmt.Sprintf("The %s id of the {resource} resource.", name),
		}

		// If the attribute is a project, we add the standard gcloud property fallback,
		// so users don't have to specify `--project` if it's already configured.
		if name == "project" {
			attr.Property = "core/project"
		}
		attributes = append(attributes, attr)
	}
	return attributes
}

// newRequest creates the `Request` part of the command definition.
func newRequest(method *api.Method, overrides *Config, model *api.API) *Request {
	// TODO(https://github.com/googleapis/librarian/issues/3290): The collection path is partially hardcoded.
	return &Request{
		APIVersion: apiVersion(overrides),
		Collection: []string{fmt.Sprintf("parallelstore.projects.locations.%s", utils.GetPluralResourceNameForMethod(method, model))},
	}
}

// newAsync creates the `Async` part of the command definition for long-running operations.
func newAsync(_ *api.Method, _ *Config) *Async {
	return &Async{
		// TODO(https://github.com/googleapis/librarian/issues/3290): The collection path is partially hardcoded.
		Collection: []string{"parallelstore.projects.locations.operations"},
	}
}

// findHelpTextRule finds the help text rule from the config that applies to the current method.
func findHelpTextRule(method *api.Method, overrides *Config) *HelpTextRule {
	if overrides.APIs == nil {
		return nil
	}
	for _, api := range overrides.APIs {
		if api.HelpText == nil {
			continue
		}
		for _, rule := range api.HelpText.MethodRules {
			if rule.Selector == strings.TrimPrefix(method.ID, ".") {
				return rule
			}
		}
	}
	return nil
}

// findFieldHelpTextRule finds the help text rule from the config that applies to the current field.
func findFieldHelpTextRule(field *api.Field, overrides *Config) *HelpTextRule {
	if overrides.APIs == nil {
		return nil
	}
	for _, api := range overrides.APIs {
		if api.HelpText == nil {
			continue
		}
		for _, rule := range api.HelpText.FieldRules {
			if rule.Selector == field.ID {
				return rule
			}
		}
	}
	return nil
}

// apiVersion extracts the API version from the configuration.
func apiVersion(overrides *Config) string {
	if len(overrides.APIs) > 0 {
		return overrides.APIs[0].APIVersion
	}
	return ""
}
