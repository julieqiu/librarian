// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package gcloud

import (
	"fmt"
	"slices"
	"strings"

	"github.com/googleapis/librarian/internal/sidekick/api"
	"github.com/googleapis/librarian/internal/surfer/gcloud/utils"
	"github.com/iancoleman/strcase"
)

// NewCommand constructs a single gcloud command definition from an API method.
// This function assembles all the necessary pieces: help text, arguments,
// request details, and async configuration.
func NewCommand(method *api.Method, overrides *Config, model *api.API, service *api.Service) (*Command, error) {
	// We look up the help text and API definition for this specific method in the
	// `gcloud.yaml` configuration file.
	rule := findHelpTextRule(method, overrides)

	// We initialize the command with some default values.
	cmd := &Command{
		AutoGenerated: true,
	}

	if len(overrides.APIs) > 0 {
		cmd.Hidden = overrides.APIs[0].RootIsHidden
	} else {
		// Default to hidden if no API overrides are provided.
		cmd.Hidden = true
	}

	// If a help text rule was found in the config, we apply it to the command.
	if rule != nil {
		cmd.HelpText = HelpText{
			Brief:       rule.HelpText.Brief,
			Description: rule.HelpText.Description,
			Examples:    strings.Join(rule.HelpText.Examples, "\n\n"),
		}
	}

	// Infer default release track from proto package.
	// TODO(https://github.com/googleapis/librarian/issues/3289): Allow gcloud config to overwrite the track for this command.
	inferredTrack := utils.InferTrackFromPackage(method.Service.Package)
	cmd.ReleaseTracks = []string{strings.ToUpper(inferredTrack)}

	// The core of the command generation happens here: we generate the arguments,
	// request details, and async configuration.
	args, err := newArguments(method, overrides, model, service)
	if err != nil {
		return nil, err
	}
	cmd.Arguments = args
	cmd.Request = newRequest(method, overrides, model, service)

	if utils.IsList(method) {
		// List commands should have an id_field to enable the --uri flag.
		cmd.Response = &Response{
			IDField: "name",
		}
		// List commands should have a default output format.
		cmd.Output = newOutputConfig(method, model)
	}

	if utils.IsUpdate(method) {
		// Standard Update methods in gcloud use the Read-Modify-Update pattern.
		cmd.Update = &UpdateConfig{
			ReadModifyUpdate: true,
		}
	}

	if method.OperationInfo != nil {
		cmd.Async = newAsync(method, model, overrides, service)
	}

	return cmd, nil
}

// newArguments generates the set of arguments for a command by parsing the
// fields of the method's request message.
//
// TODO(https://github.com/googleapis/librarian/issues/3412): Refactor to use a dispatch pattern
// (IsIgnored, IsResourceArg, IsArg) to handle field processing.
func newArguments(method *api.Method, overrides *Config, model *api.API, service *api.Service) (Arguments, error) {
	args := Arguments{}
	if method.InputType == nil {
		return args, nil
	}

	// We iterate over each field in the method's request message.
	for _, field := range method.InputType.Fields {
		// We process each field and its sub-fields recursively.
		// TODO(https://github.com/googleapis/librarian/issues/3413): Improve error handling strategy (Error vs Skip) and messaging.
		if err := addFlattenedParams(field, field.JSONName, &args, overrides, model, service, method); err != nil {
			return Arguments{}, err
		}
	}
	return args, nil
}

// shouldSkipParam determines if a field should be excluded from the generated command arguments.
func shouldSkipParam(field *api.Field, method *api.Method) bool {
	// We don't skip the primary resource field, even if it's named "parent" or "name".
	if utils.IsPrimaryResource(field, method) {
		return false
	}

	// The "parent" field is usually implicit in the command context (handled by the primary resource or hierarchy).
	if field.Name == "parent" {
		return true
	}

	// The "name" field is usually the primary resource identifier, handled separately.
	if field.Name == "name" {
		return true
	}

	// The "update_mask" field is handled automatically by the gcloud framework.
	if field.Name == "update_mask" {
		return true
	}

	// For List methods, standard pagination/filtering arguments are handled by gcloud.
	if utils.IsList(method) {
		switch field.Name {
		case "page_size", "page_token", "filter", "order_by":
			return true
		}
	}

	// Output-only fields are read-only and should not be settable via CLI flags.
	if slices.Contains(field.Behavior, api.FIELD_BEHAVIOR_OUTPUT_ONLY) {
		return true
	}

	// For Update commands, fields marked as IMMUTABLE cannot be changed and should be hidden.
	if utils.IsUpdate(method) && slices.Contains(field.Behavior, api.FIELD_BEHAVIOR_IMMUTABLE) {
		return true
	}

	return false
}

// addFlattenedParams recursively processes a field and its sub-fields to generate
// command-line flags. This function identifies primary resources and handles
// nested messages by "flattening" them into top-level flags.
func addFlattenedParams(field *api.Field, prefix string, args *Arguments, overrides *Config, model *api.API, service *api.Service, method *api.Method) error {
	// We check if the field should be skipped entirely.
	if shouldSkipParam(field, method) {
		return nil
	}

	// We check if the current field represents the primary resource of the command.
	// This check happens at every level of nesting (e.g., `instance.name`).
	if utils.IsPrimaryResource(field, method) {
		param := newPrimaryResourceParam(field, method, model, overrides, service)
		args.Params = append(args.Params, param)
		return nil
	}

	// If the field is a nested message (and not a map), we recurse into its fields.
	if field.MessageType != nil && !field.Map {
		for _, f := range field.MessageType.Fields {
			if err := addFlattenedParams(f, fmt.Sprintf("%s.%s", prefix, f.JSONName), args, overrides, model, service, method); err != nil {
				return err
			}
		}
		return nil
	}

	// If the field is a scalar, map, or enum, we generate a parameter for it.
	param, err := newParam(field, prefix, overrides, model, service, method)
	if err != nil {
		return err
	}
	args.Params = append(args.Params, param)
	return nil
}

// newParam creates a single command-line argument (a `Param` struct) from a proto field.
func newParam(field *api.Field, apiField string, overrides *Config, model *api.API, service *api.Service, method *api.Method) (Param, error) {
	// We initialize the Param with the basic information derived from the field.
	// TODO(https://github.com/googleapis/librarian/issues/3414): Abstract away casing logic in the model.
	param := Param{
		// The command-line flag name is the kebab-case version of the field name.
		// Example: `requestId` -> `request-id`
		ArgName: strcase.ToKebab(field.Name),
		// The `api_field` is the dot-separated path to the field in the request message.
		APIField: apiField,
		// We determine if the field is required based on the `(google.api.field_behavior)` annotation.
		Required: field.DocumentAsRequired(),
		// We check if the field is repeated in the proto.
		Repeated: field.Repeated,
	}

	// Now we handle the different types of fields.
	if field.ResourceReference != nil {
		// If the field is a resource reference (e.g., a field for a network), we
		// generate a `ResourceSpec` for it. This tells gcloud how to parse the
		// resource name provided by the user.
		spec, err := newResourceReferenceSpec(field, model, overrides, service)
		if err != nil {
			return Param{}, err
		}
		param.ResourceSpec = spec
		param.ResourceMethodParams = map[string]string{
			apiField: "{__relative_name__}",
		}
	} else if field.Map {
		// If the field is a map, we generate a spec for its key-value pairs.
		param.Repeated = true
		param.Spec = []ArgSpec{
			{APIField: "key"},
			{APIField: "value"},
		}
	} else if field.EnumType != nil {
		// If the field is an enum, we generate a list of choices for the flag.
		for _, v := range field.EnumType.Values {
			// We skip the default "UNSPECIFIED" value, as it's not a valid choice for the user.
			if strings.HasSuffix(v.Name, "_UNSPECIFIED") {
				continue
			}
			param.Choices = append(param.Choices, Choice{
				ArgValue:  strcase.ToKebab(v.Name),
				EnumValue: v.Name,
			})
		}
	} else {
		// If it's a scalar type (string, int, bool, etc.), we map its proto type
		// to the corresponding gcloud type.
		param.Type = utils.GetGcloudType(field.Typez)
	}

	// For Update commands, maps and repeated fields are often clearable.
	if utils.IsUpdate(method) && param.Repeated {
		param.Clearable = true
	}

	// We try to find help text for this field in the `gcloud.yaml` config.
	// If none is found, we generate a default help text.
	if rule := findFieldHelpTextRule(field, overrides); rule != nil {
		param.HelpText = rule.HelpText.Brief
	} else {
		// TODO(https://github.com/googleapis/librarian/issues/3033): improve default help text inference
		param.HelpText = fmt.Sprintf("Value for the `%s` field.", strcase.ToKebab(field.Name))
	}
	return param, nil
}

// newPrimaryResourceParam creates the main positional resource argument for a command.
// This is the argument that represents the resource being acted upon (e.g., the instance name).
func newPrimaryResourceParam(field *api.Field, method *api.Method, model *api.API, _ *Config, service *api.Service) Param {
	// We first need to get the full resource definition for the method.
	resource := utils.GetResourceForMethod(method, model)
	var segments []api.PathSegment
	// TODO(https://github.com/googleapis/librarian/issues/3415): Support multiple resource patterns and multitype resources.
	if resource != nil && len(resource.Patterns) > 0 {
		segments = resource.Patterns[0]
	}

	// For List methods, the primary resource is the parent of the method's resource.
	if utils.IsList(method) {
		segments = utils.GetParentFromSegments(segments)
	}

	// We determine the singular name of the resource.
	resourceName := strcase.ToSnake(strings.TrimSuffix(field.Name, "_id"))
	if field.Name == "name" || utils.IsList(method) {
		resourceName = utils.GetSingularFromSegments(segments)
	}

	// We generate a helpful help text.
	var helpText string
	switch {
	case utils.IsCreate(method):
		helpText = fmt.Sprintf("The %s to create.", resourceName)
	case utils.IsList(method):
		helpText = fmt.Sprintf("The project and location for which to retrieve %s information.", utils.GetPluralFromSegments(segments))
	default:
		helpText = fmt.Sprintf("The %s to operate on.", resourceName)
	}

	// We construct the gcloud collection path from the resource's pattern string.
	collectionPath := utils.GetCollectionPathFromSegments(segments)
	hostParts := strings.Split(service.DefaultHost, ".")
	shortServiceName := hostParts[0]

	// We assemble the final `Param` struct.
	param := Param{
		HelpText:          helpText,
		IsPositional:      !utils.IsList(method),
		IsPrimaryResource: true,
		Required:          true,
		ResourceSpec: &ResourceSpec{
			Name:                  resourceName,
			PluralName:            utils.GetPluralFromSegments(segments),
			Collection:            fmt.Sprintf("%s.%s", shortServiceName, collectionPath),
			DisableAutoCompleters: false,
			Attributes:            newAttributesFromSegments(segments),
		},
	}

	if utils.IsCreate(method) {
		param.RequestIDField = strcase.ToLowerCamel(field.Name)
	}

	return param
}

// newResourceReferenceSpec creates a ResourceSpec for a field that references
// another resource type (e.g., a `--network` flag).
func newResourceReferenceSpec(field *api.Field, model *api.API, _ *Config, service *api.Service) (*ResourceSpec, error) {
	// We iterate through all the resource definitions in the API model to find the
	// one that matches the type of our resource reference.
	for _, def := range model.ResourceDefinitions {
		if def.Type == field.ResourceReference.Type {
			if len(def.Patterns) == 0 {
				return nil, fmt.Errorf("resource definition for %q has no patterns", def.Type)
			}
			// TODO(https://github.com/googleapis/librarian/issues/3415): Support multiple resource patterns and multitype resources.
			segments := def.Patterns[0]

			// We determine the plural name, using the explicit `plural` field if available,
			// and falling back to parsing the pattern otherwise.
			pluralName := def.Plural
			if pluralName == "" {
				pluralName = utils.GetPluralFromSegments(segments)
			}

			// We determine the singular name from the pattern.
			name := utils.GetSingularFromSegments(segments)

			// We construct the full gcloud collection path for the referenced resource
			//assuming the current service is the current command.
			hostParts := strings.Split(service.DefaultHost, ".")
			shortServiceName := hostParts[0]
			baseCollectionPath := utils.GetCollectionPathFromSegments(segments)
			fullCollectionPath := fmt.Sprintf("%s.%s", shortServiceName, baseCollectionPath)

			// We assemble and return the `ResourceSpec`.
			return &ResourceSpec{
				Name:       name,
				PluralName: pluralName,
				Collection: fullCollectionPath,
				// TODO(https://github.com/googleapis/librarian/issues/3416): Investigate and enable auto-completers for referenced resources.
				DisableAutoCompleters: true,
				Attributes:            newAttributesFromSegments(segments),
			}, nil
		}
	}
	return nil, fmt.Errorf("resource definition not found for type %q", field.ResourceReference.Type)
}

// newAttributesFromSegments parses a structured resource pattern and extracts the attributes
// that make up the resource's name.
func newAttributesFromSegments(segments []api.PathSegment) []Attribute {
	var attributes []Attribute

	// We iterate over the segments of the pattern.
	for i, part := range segments {
		// A variable segment is enclosed in curly braces.
		if part.Variable == nil {
			continue
		}

		// The `attribute_name` is the name of the variable (e.g., "project").
		if len(part.Variable.FieldPath) == 0 {
			continue
		}
		name := part.Variable.FieldPath[len(part.Variable.FieldPath)-1]
		var parameterName string

		// The `parameter_name` is derived from the preceding literal segment
		// (e.g., "projects" -> "projectsId"). This is a gcloud convention.
		if i > 0 && segments[i-1].Literal != nil {
			parameterName = *segments[i-1].Literal + "Id"
		} else {
			// This is a fallback for the unlikely case that a pattern starts with a variable.
			parameterName = name + "sId"
		}

		attr := Attribute{
			AttributeName: name,
			ParameterName: parameterName,
			Help:          fmt.Sprintf("The %s id of the {resource} resource.", name),
		}

		// If the attribute is a project, we add the standard gcloud property fallback,
		// so users don't have to specify `--project` if it's already configured.
		if name == "project" {
			attr.Property = "core/project"
		}
		attributes = append(attributes, attr)
	}
	return attributes
}

// newRequest creates the `Request` part of the command definition.
func newRequest(method *api.Method, overrides *Config, _ *api.API, service *api.Service) *Request {
	req := &Request{
		APIVersion: apiVersion(overrides),
		Collection: newCollectionPath(method, service, false),
	}

	// For custom methods (AIP-136), the `method` field in the request configuration
	// MUST match the custom verb defined in the HTTP binding (e.g., ":exportData" -> "exportData").
	if len(method.PathInfo.Bindings) > 0 && method.PathInfo.Bindings[0].PathTemplate.Verb != nil {
		req.Method = *method.PathInfo.Bindings[0].PathTemplate.Verb
	} else if !utils.IsStandardMethod(method) {
		// We treat any non-standard method as a custom method (AIP-136).
		commandName, _ := utils.GetCommandName(method)
		// GetCommandName returns snake_case (e.g. "export_data"), but request.method expects camelCase (e.g. "exportData").
		req.Method = strcase.ToLowerCamel(commandName)
	}

	return req
}

// newAsync creates the `Async` part of the command definition for long-running operations.
func newAsync(method *api.Method, model *api.API, _ *Config, service *api.Service) *Async {
	async := &Async{
		Collection: newCollectionPath(method, service, true),
	}

	// Determine if the operation result should be extracted as the resource.
	// This is true if the operation response type matches the method's resource type.
	// We reuse the 'resource' variable looked up earlier.
	resource := utils.GetResourceForMethod(method, model)
	if resource == nil {
		return async
	}

	// Heuristic: Check if response type ID (e.g. ".google.cloud.parallelstore.v1.Instance")
	// matches the resource singular name or type.
	responseTypeID := method.OperationInfo.ResponseTypeID
	// Extract short name from FQN (last element after dot)
	responseTypeName := responseTypeID
	if idx := strings.LastIndex(responseTypeID, "."); idx != -1 {
		responseTypeName = responseTypeID[idx+1:]
	}

	singular := utils.GetSingularResourceNameForMethod(method, model)
	if strings.EqualFold(responseTypeName, singular) || strings.HasSuffix(resource.Type, "/"+responseTypeName) {
		async.ExtractResourceResult = true
	} else {
		async.ExtractResourceResult = false
	}

	return async
}

// newCollectionPath constructs the gcloud collection path(s) for a request or async operation.
// It follows AIP-127 and AIP-132 by extracting the collection structure directly from
// the method's HTTP annotation (PathInfo).
func newCollectionPath(method *api.Method, service *api.Service, isAsync bool) []string {
	var collections []string
	hostParts := strings.Split(service.DefaultHost, ".")
	shortServiceName := hostParts[0]

	// Iterate over all bindings (primary + additional) to support multitype resources (AIP-127).
	for _, binding := range method.PathInfo.Bindings {
		if binding.PathTemplate == nil {
			continue
		}

		basePath := utils.ExtractPathFromSegments(binding.PathTemplate.Segments)

		if basePath == "" {
			continue
		}

		if isAsync {
			// For Async operations (AIP-151), the operations resource usually resides in the
			// parent collection of the primary resource. We replace the last segment (the resource collection)
			// with "operations".
			// Example: projects.locations.instances -> projects.locations.operations
			if idx := strings.LastIndex(basePath, "."); idx != -1 {
				basePath = basePath[:idx] + ".operations"
			} else {
				basePath = "operations"
			}
		}

		fullPath := fmt.Sprintf("%s.%s", shortServiceName, basePath)
		collections = append(collections, fullPath)
	}

	// Remove duplicates if any.
	slices.Sort(collections)
	return slices.Compact(collections)
}

// newOutputConfig generates the output configuration for List commands.
func newOutputConfig(method *api.Method, _ *api.API) *OutputConfig {
	// We only generate output config for list methods.
	if !utils.IsList(method) {
		return nil
	}

	resourceMsg := utils.FindResourceMessage(method.OutputType)
	if resourceMsg == nil {
		return nil
	}

	format := newFormat(resourceMsg)
	if format == "" {
		return nil
	}

	return &OutputConfig{
		Format: format,
	}
}

// newFormat generates a gcloud table format string from a message definition.
func newFormat(message *api.Message) string {
	var sb strings.Builder
	first := true

	for _, f := range message.Fields {
		// Sanitize field name to prevent DSL injection.
		if !utils.IsSafeName(f.JSONName) {
			continue
		}

		// Include scalars and enums.
		isScalar := f.Typez == api.STRING_TYPE ||
			f.Typez == api.INT32_TYPE || f.Typez == api.INT64_TYPE ||
			f.Typez == api.BOOL_TYPE || f.Typez == api.ENUM_TYPE ||
			f.Typez == api.DOUBLE_TYPE || f.Typez == api.FLOAT_TYPE

		if isScalar {
			if !first {
				// The newline is not strictly required by gcloud, but we add it to
				// match the existing format convention which improves readability in the YAML.
				sb.WriteString(",\n")
			}
			if f.Repeated {
				// Format repeated scalars with .join(',').
				sb.WriteString(f.JSONName)
				sb.WriteString(".join(',')")
			} else {
				sb.WriteString(f.JSONName)
			}
			first = false
			continue
		}

		// Include timestamps (usually messages like google.protobuf.Timestamp).
		if f.MessageType != nil && strings.HasSuffix(f.TypezID, ".Timestamp") {
			if !first {
				// The newline is not strictly required by gcloud, but we add it to
				// match the existing format convention which improves readability in the YAML.
				sb.WriteString(",\n")
			}
			sb.WriteString(f.JSONName)
			first = false
		}
	}

	if sb.Len() == 0 {
		return ""
	}
	return fmt.Sprintf("table(\n%s)", sb.String())
}

// findHelpTextRule finds the help text rule from the config that applies to the current method.
func findHelpTextRule(method *api.Method, overrides *Config) *HelpTextRule {
	if overrides.APIs == nil {
		return nil
	}
	for _, api := range overrides.APIs {
		if api.HelpText == nil {
			continue
		}
		for _, rule := range api.HelpText.MethodRules {
			if rule.Selector == strings.TrimPrefix(method.ID, ".") {
				return rule
			}
		}
	}
	return nil
}

// findFieldHelpTextRule finds the help text rule from the config that applies to the current field.
func findFieldHelpTextRule(field *api.Field, overrides *Config) *HelpTextRule {
	if overrides.APIs == nil {
		return nil
	}
	for _, api := range overrides.APIs {
		if api.HelpText == nil {
			continue
		}
		for _, rule := range api.HelpText.FieldRules {
			if rule.Selector == field.ID {
				return rule
			}
		}
	}
	return nil
}

// apiVersion extracts the API version from the configuration.
func apiVersion(overrides *Config) string {
	if len(overrides.APIs) > 0 {
		return overrides.APIs[0].APIVersion
	}
	return ""
}
