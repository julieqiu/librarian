// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package gcloud

import (
	"fmt"
	"strings"

	"github.com/googleapis/librarian/internal/sidekick/api"
	"github.com/googleapis/librarian/internal/surfer/gcloud/utils"
	"github.com/iancoleman/strcase"
)

// NewCommand constructs a single gcloud command definition from an API method.
// This function assembles all the necessary pieces: help text, arguments,
// request details, and async configuration.
func NewCommand(method *api.Method, overrides *Config, model *api.API, service *api.Service) (*Command, error) {
	// We look up the help text and API definition for this specific method in the
	// `gcloud.yaml` configuration file.
	rule := findHelpTextRule(method, overrides)

	// We initialize the command with some default values.
	cmd := &Command{
		AutoGenerated: true,
	}

	if len(overrides.APIs) > 0 {
		cmd.Hidden = overrides.APIs[0].RootIsHidden
	} else {
		// Default to hidden if no API overrides are provided.
		cmd.Hidden = true
	}

	// If a help text rule was found in the config, we apply it to the command.
	if rule != nil {
		cmd.HelpText = HelpText{
			Brief:       rule.HelpText.Brief,
			Description: rule.HelpText.Description,
			Examples:    strings.Join(rule.HelpText.Examples, "\n\n"),
		}
	}

	// Infer default release track from proto package.
	// TODO(https://github.com/googleapis/librarian/issues/3289): Allow gcloud config to overwrite the track for this command.
	inferredTrack := utils.InferTrackFromPackage(method.Service.Package)
	cmd.ReleaseTracks = []string{strings.ToUpper(inferredTrack)}

	// The core of the command generation happens here: we generate the arguments,
	// request details, and async configuration.
	args, err := newArguments(method, overrides, model, service)
	if err != nil {
		return nil, err
	}
	cmd.Arguments = args
	cmd.Request = newRequest(method, overrides, model)

	if utils.IsList(method) {
		// List commands should have an id_field to enable the --uri flag.
		cmd.Response = &Response{
			IDField: "name",
		}
	}

	if utils.IsUpdate(method) {
		// Standard Update methods in gcloud use the Read-Modify-Update pattern.
		cmd.Update = &UpdateConfig{
			ReadModifyUpdate: true,
		}
	}

	return cmd, nil
}

// newArguments generates the set of arguments for a command by parsing the
// fields of the method's request message.
//
// TODO(https://github.com/googleapis/librarian/issues/3412): Refactor to use a dispatch pattern
// (IsIgnored, IsResourceArg, IsArg) to handle field processing.
func newArguments(_ *api.Method, _ *Config, _ *api.API, _ *api.Service) (Arguments, error) {
	return Arguments{}, nil
}

// newRequest creates the `Request` part of the command definition.
func newRequest(method *api.Method, overrides *Config, model *api.API) *Request {
	// TODO(https://github.com/googleapis/librarian/issues/3290): The collection path is partially hardcoded.
	return &Request{
		APIVersion: apiVersion(overrides),
		Collection: []string{fmt.Sprintf("parallelstore.projects.locations.%s", utils.GetPluralResourceNameForMethod(method, model))},
	}
}

// findHelpTextRule finds the help text rule from the config that applies to the current method.
func findHelpTextRule(method *api.Method, overrides *Config) *HelpTextRule {
	if overrides.APIs == nil {
		return nil
	}
	for _, api := range overrides.APIs {
		if api.HelpText == nil {
			continue
		}
		for _, rule := range api.HelpText.MethodRules {
			if rule.Selector == strings.TrimPrefix(method.ID, ".") {
				return rule
			}
		}
	}
	return nil
}

// apiVersion extracts the API version from the configuration.
func apiVersion(overrides *Config) string {
	if len(overrides.APIs) > 0 {
		return overrides.APIs[0].APIVersion
	}
	return ""
}

// newParam creates a single command-line argument (a `Param` struct) from a proto field.
func newParam(field *api.Field, apiField string, overrides *Config, _ *api.API, _ *api.Service, method *api.Method) (Param, error) {
	// We initialize the Param with the basic information derived from the field.
	// TODO(https://github.com/googleapis/librarian/issues/3414): Abstract away casing logic in the model.
	param := Param{
		// The command-line flag name is the kebab-case version of the field name.
		// Example: `requestId` -> `request-id`
		ArgName: strcase.ToKebab(field.Name),
		// The `api_field` is the dot-separated path to the field in the request message.
		APIField: apiField,
		// We determine if the field is required based on the `(google.api.field_behavior)` annotation.
		Required: field.DocumentAsRequired(),
		// We check if the field is repeated in the proto.
		Repeated: field.Repeated,
	}

	// Now we handle the different types of fields.
	if field.ResourceReference != nil {
		// TODO(https://github.com/googleapis/librarian/issues/3417): Implement resource reference handling.
		return Param{}, fmt.Errorf("resource references are not yet supported")
	} else if field.Map {
		// If the field is a map, we generate a spec for its key-value pairs.
		param.Repeated = true
		param.Spec = []ArgSpec{
			{APIField: "key"},
			{APIField: "value"},
		}
	} else if field.EnumType != nil {
		// If the field is an enum, we generate a list of choices for the flag.
		for _, v := range field.EnumType.Values {
			// We skip the default "UNSPECIFIED" value, as it's not a valid choice for the user.
			if strings.HasSuffix(v.Name, "_UNSPECIFIED") {
				continue
			}
			param.Choices = append(param.Choices, Choice{
				ArgValue:  strcase.ToKebab(v.Name),
				EnumValue: v.Name,
			})
		}
	} else {
		// If it's a scalar type (string, int, bool, etc.), we map its proto type
		// to the corresponding gcloud type.
		param.Type = utils.GetGcloudType(field.Typez)
	}

	// For Update commands, maps and repeated fields are often clearable.
	if utils.IsUpdate(method) && param.Repeated {
		param.Clearable = true
	}

	// We try to find help text for this field in the `gcloud.yaml` config.
	// If none is found, we generate a default help text.
	if rule := findFieldHelpTextRule(field, overrides); rule != nil {
		param.HelpText = rule.HelpText.Brief
	} else {
		// TODO(https://github.com/googleapis/librarian/issues/3033): improve default help text inference
		param.HelpText = fmt.Sprintf("Value for the `%s` field.", strcase.ToKebab(field.Name))
	}
	return param, nil
}

// findFieldHelpTextRule finds the help text rule from the config that applies to the current field.
func findFieldHelpTextRule(field *api.Field, overrides *Config) *HelpTextRule {
	if overrides.APIs == nil {
		return nil
	}
	for _, api := range overrides.APIs {
		if api.HelpText == nil {
			continue
		}
		for _, rule := range api.HelpText.FieldRules {
			if rule.Selector == field.ID {
				return rule
			}
		}
	}
	return nil
}
